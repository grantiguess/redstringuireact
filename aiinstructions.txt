# Redstring Project: AI Assistant Guide

This document provides a comprehensive guide for AI assistants working on the Redstring project. It outlines the core philosophy, system architecture, key components, and development guidelines.

## 1. Core Philosophy & High-Level Architecture

Redstring is a sophisticated React-based cognitive interface designed for constructing, traversing, and interacting with networks of conceptual nodes. It aims to be a "cognitive scaffold," mirroring the recursive, associative, contextual, and non-linear nature of human thought. The application allows users to build and navigate graphs where nodes can represent ideas and can themselves contain other graphs, enabling deep hierarchical recursion and composition.

**Core Technical Aspects:**
- **Frontend:** Fully React-rendered, with UI logic and state management handled on the client-side.
- **State Management:** Zustand is used for managing global state, including the active graph context, node/edge data, saved states, multi-graph support, and interactive logic.
- **Central Orchestration:** `src/NodeCanvas.jsx` is the pivotal component, mediating user interactions (mouse, touch, keyboard), graph state, view transformations (pan, zoom, drag), and the recursive structure engine.
- **Rendering:** All graph rendering occurs within a React-managed `<svg>` canvas. Node rendering is dynamic, handling dimensions, image scaling, and connection positioning.

**Philosophical Principles:**
Redstring is more than a tool; it's an interface for thinking in networks. Its design is guided by key principles:
1.  **All is a Graph:** Every concept is a node, every relationship an edge.
2.  **Recursion as Ontology:** Nodes can contain entire graphs, reflecting cognitive abstraction and layering.
3.  **Embodied Semantics:** Users spatially arrange knowledge, connecting meanings through direct manipulation.
4.  **Open Topology:** No predefined root; users start where meaning begins for them, supporting a rhizomatic structure.
5.  **Dual Interface (Syntax and Mythos):** Panels provide structured data access (syntax), while the canvas offers a symbolic, spatial, and intuitive interaction space (mythos).

## 2. Key Systems & Components

### 2.1. Data Model & State (`/core`, `/store`)

-   **Core Data Structures (`/core`):** The fundamental data structures are defined in this directory.
    -   `Entry.js`: The base class for all named entities, providing properties like `id`, `name`, `description`.
    -   `Graph.js`: Extends `Entry`. Represents a graph containing nodes and edges. Manages the graph's structure.
    -   `Node.js`: Extends `Entry`. Represents a node on the canvas. Crucially, a `Node` can contain one or more `Graph`s as its "definitions", enabling recursion. It also tracks its position (`x`, `y`), scale, and connections.
    -   `Edge.js`: Extends `Entry`. Represents a connection between two nodes (`sourceId`, `destinationId`).
-   **State Management (`/store/graphStore.js`):**
    -   Zustand is used for all global state management.
    -   The store is structured around Maps for efficient data access: `graphs`, `nodes`, `edges`.
    -   **Prototypes vs. Instances:** The store distinguishes between node *prototypes* (the core concept or "Thing") and node *instances* (a specific representation of a prototype on a particular graph). This is a fundamental concept.
        -   `nodePrototypes`: A Map storing the canonical definition of a node (name, color, definitions, etc.).
        -   `graphs.instances`: Each graph object contains a Map of its node instances, which store position, scale, and a `prototypeId` linking back to the `nodePrototypes` map.

### 2.2. The Canvas (`NodeCanvas.jsx`)

`NodeCanvas.jsx` is the heart of the application, responsible for rendering the graph and handling almost all user interactions.

-   **Rendering:**
    -   The entire graph is rendered within a single, large `<svg>` element.
    -   Pan and zoom are implemented by applying a `transform` to a `<g>` element that wraps all rendered nodes and edges.
    -   **Z-Indexing:** Visual stacking order is critical and managed manually by changing the render order of elements within the SVG. For example, a selected or previewing node and its Pie Menu are re-rendered later in the SVG map to appear on top. Dragged nodes are rendered last to appear above everything else.
    -   **Inner Network Previews:** The `InnerNetwork.jsx` component is used to render a scaled-down, non-interactive preview of a graph inside an expanded node. `GraphPreview.jsx` serves a similar purpose in the left panel.
-   **View Manipulation (Pan & Zoom):**
    -   `handleWheel` in `NodeCanvas.jsx` implements sophisticated, industry-standard logic to differentiate between mouse wheels and trackpads for intuitive panning and zooming across platforms.
    -   It uses a history of scroll deltas (`deltaHistoryRef`) and heuristics (fractional values, horizontal movement, value magnitude) to reliably detect the input device.
    -   **Mac Trackpad:** Pinch-to-zoom (`Ctrl` + scroll) and two-finger pan are supported.
    -   **Mouse Wheel:** Standard scroll-to-zoom functionality.
    -   View state (pan/zoom) is saved to localStorage per graph and restored when switching between graphs.
-   **User Interaction:**
    -   **Mouse Events:** Differentiates between clicks, drags, and long presses to trigger different actions (selection, node dragging, connection drawing).
    -   **Selection:** Supports single-click selection, multi-selection (with `Ctrl`/`Cmd` key), and a drag-to-select rectangle.
    -   **Keyboard Shortcuts (`useKeyboardShortcuts.js`):** Handles keyboard-based panning (`WASD`, arrows) and zooming (`Shift`, `Space`).

### 2.3. Node Lifecycle & Interactions

-   **Node Component (`Node.jsx`):**
    -   Renders an individual node (instance) on the canvas.
    -   Dynamically calculates its own dimensions based on its name, thumbnail, and preview state using the `getNodeDimensions` utility.
    -   Manages its appearance based on state props from `NodeCanvas.jsx` (`isSelected`, `isDragging`, `isPreviewing`).
    -   Handles the rendering of its `InnerNetwork` and description when in preview mode.
-   **Node Spawning via Drag-and-Drop:**
    -   This system enables creating new node instances by dragging representations from UI panels onto the canvas. It is designed to be a fluid, intuitive way to compose graphs.
    -   **Draggable Sources:** Node representations in the `Header` (`HeaderGraphTab.jsx`), the "Open Things" list (`GraphListItem.jsx`), and the "Saved Things" list (`SavedNodeItem` in `Panel.jsx`) are draggable sources.
    -   **Mechanism:** Uses `react-dnd`. Draggable items have the type `SPAWNABLE_NODE` and carry the `prototypeId` of the node concept they represent.
    -   **Drag Preview:** `SpawningNodeDragLayer.jsx` renders a custom, scaled-down `Node` component that follows the cursor, creating the appearance of dragging an actual node. It is designed to be visually smooth and appear "above" other UI elements like the header.
    -   **Drop Action:** `NodeCanvas.jsx` is a drop target. On drop, it creates a **new instance** of the dragged prototype in the current active graph at the cursor's position.
    -   **Recursive Spawning:** A key feature is the ability to create recursive structures. When dragging a defining node into its own definition graph, the system creates a new instance with a new ID, maintaining the parent-child relationship. This enables infinite conceptual nesting, a core philosophical goal.
-   **Inline Editing:**
    -   Triggered from the Pie Menu's "Edit" button.
    -   Simultaneously enables an input field on the `Node.jsx` component on the canvas and opens/activates the corresponding node tab in the right-hand panel.
    -   State is synchronized via the Zustand store, so changes in one location are immediately reflected in the other.
-   **Pie Menu (`PieMenu.jsx`):**
    -   A circular, contextual menu that appears on single-node selection.
    -   Its state (`selectedNodeIdForPieMenu`, `isTransitioningPieMenu`, `currentPieMenuData`) is managed in `NodeCanvas.jsx`.
    -   Buttons are dynamically generated based on context (e.g., "Expand" vs. "Contract").
    -   Features a coordinated pop-in/shrink-out animation lifecycle. The menu's `onExitAnimationComplete` callback is crucial for orchestrating state transitions in `NodeCanvas.jsx`, preventing visual glitches.
-   **Node Preview / Expansion ("Decompose"):**
    -   Triggered from the Pie Menu. A node can expand in-place to show its definition graph.
    -   The `previewingNodeId` state in `NodeCanvas.jsx` controls this.
    -   The node's dimensions animate smoothly to accommodate the `InnerNetwork` preview and a dynamic description area.
    -   The description is sourced from the active definition graph, making it context-aware.
-   **Abstraction Carousel (`AbstractionCarousel.jsx`):**
    -   A major UI feature for exploring the conceptual hierarchy of a node.
    -   Triggered from the "Abstraction" button on the Pie Menu.
    -   It displays a vertical, interactive carousel of nodes representing different levels of abstraction, from "more generic" to "more specific".
    -   **Physics-Based Scrolling:** Implements its own physics engine using a reducer (`physicsReducer`) for a fluid, momentum-based scrolling experience with snapping.
    -   **Dynamic Content:** The chain of nodes and their colors are generated dynamically based on the selected node's color and name.
    -   **Integration:** It overlays the canvas and communicates with `NodeCanvas.jsx` via callbacks to update the scale and dimensions of the focused node in the carousel, creating a seamless visual effect.

### 2.4. UI Panels & Navigation

-   **Header (`Header.jsx`):**
    -   Contains the main application menu (`RedstringMenu.jsx`) and the graph tabs (`HeaderGraphTab.jsx`).
    -   The header logo animates to reveal the menu.
    -   The central area displays tabs for all open graphs, allowing for quick navigation. The active graph's tab is centered.
-   **Left Panel (`Panel.jsx`):**
    -   Provides two views: "Saved Things" (a bookmarking system for nodes/graphs) and "Open Things" (a list of all currently open graphs).
    -   Items in these lists (`SavedNodeItem`, `GraphListItem`) are draggable to the canvas to spawn new nodes.
-   **Right Panel (`Panel.jsx`):**
    -   Acts as an inspector. It has a "Home" tab for the active graph's metadata and tabs for any nodes the user has chosen to inspect.
    -   Node tabs allow for editing the node's name, description (bio), and image.
-   **Type List (`TypeList.jsx`):**
    -   A retractable bar at the bottom of the screen that allows for viewing and interacting with Node Types. This system is for classifying nodes (e.g., "Person", "Place", "Concept").

### 2.5. Advanced Systems

-   **Context-Aware Definitions:**
    -   A node can have multiple definition graphs. The system remembers which definition is preferred for a given context.
    -   Uses a `nodeDefinitionIndices` Map in `NodeCanvas.jsx` with a `"nodeId-graphId"` key to track the active definition index for a node within a specific parent graph.
    -   This allows a "Car" node, for example, to show its "Engine" definition in a "Mechanical" graph but its "Exterior" definition in a "Design" graph.
    -   Navigation controls in both the expanded node view and the right panel are synchronized.
-   **Directional Edges:**
    -   Edges are fundamentally undirected, but arrows can be added to indicate directionality relative to a node.
    -   The `Edge` data model contains a `directionality: { arrowsToward: Set<nodeId> }` property.
    -   Hovering an edge on the canvas reveals clickable dots to toggle the persistent arrow state, which is saved with the graph.
-   **File Management (`RedstringMenu.jsx`, `fileStorage.js`):**
    -   The application is centered around a single "universe" file (`.redstring`).
    -   `RedstringMenu` provides "New", "Open", "Save", and "Recent Files" actions.
    -   **Persistence:** File handles and recent file lists are stored in IndexedDB, allowing for quick reconnection across browser sessions.
    -   **Auto-Save:** Changes are auto-saved to the connected universe file to prevent data loss.
-   **Web Workers (`canvasWorker.js`, `useCanvasWorker.js`):**
    -   Computationally intensive tasks like pan, zoom, and selection box calculations are offloaded to a Web Worker to keep the main UI thread responsive.

## 3. Developer Guidelines

1.  **Respect the Architecture:** Always consider the core philosophy and the central role of `NodeCanvas.jsx`.
2.  **State Management:** Be mindful of the Zustand store structure. Use existing selectors and actions where possible. Avoid direct state mutation.
3.  **Race Conditions & Effects:** Be extremely careful with `useEffect` dependencies, especially when dealing with state that changes frequently (e.g., `currentDefinitionIndex`). Incorrect dependencies can cause state resets and race conditions. Use refs (`useRef`) to track state across renders without triggering effects when appropriate.
4.  **Type Consistency:** Ensure functions and store actions return data in the expected format (e.g., `Set` vs. `Array`). The application expects `Set` objects for collections like `expandedGraphIds`.
5.  **Debugging:**
    -   Use the in-app Debug Overlay (toggleable from the "View" menu) to inspect state.
    -   For complex UI interactions involving multiple components and animations (like the Pie Menu or Abstraction Carousel), use `console.log` liberally to trace state changes, prop values, and event firing sequences across components.
6.  **Testing:** Note the presence of test files (e.g., `App.test.jsx`, `NodeCanvas.test.jsx`). New features or significant refactors should ideally be accompanied by relevant tests.
